# -*- coding: utf-8 -*-
"""08/07CTP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wFuAnNN2vNSlY6ti2pzguIuSRxT24INl
"""

'''sortings :
 bubble
 counting sort '''

'''
Algo:
1.start from the beginning of the array/list2.
2.compare each pair to adjacent number
3.if latest element is greater than adjscent
4.repeat the process till n-1
5.after each pass/cycle,largest unsorted element would be in correct pos
6.repeat pass till all the elements are sorted
pseudo:
for  i ->0 to n-1:
for j ->0 to n-i-2:
if a[j]>a[j+1]:
swap(a[j],a[j+1])
'''


def bubble_sort(arr):
  n=len(arr)
  for i in range(n):
    for j in range(0,n-i-1):
      if arr[j]>arr[j+1]:
        arr[j],arr[j+1]=arr[j+1],arr[j]
size=int(input("Enter  the number of elements:"))
arr=[]
print("Enter the elements:")
for _ in range(size):
    arr.append((input(_)))
print("Original list:",arr)
bubble_sort(arr)
print("BubbleSorted:",arr)

'''
  non-comparision sort
  1.no negitive number
  2.no -long number
  3.short confined number only ex: 0-100
  algorithm:
  1.find max min of array
  2.min!<0
  3.create a count array to store the frequency of numbers
  4.modify the count array for each element to be store the sum of previous counts
  5.place the output array back to the  original array
  pseudo code:
  countsort (arr, n):
  1.find  the max in arr
  2.create count (0-max)
  3.for i->0 to n-1:
  count[a[i]]+=1
  4.for i->1 to max:
  count[i]+=count[i-1]
  create output arr[n]
  5.for i->n-1 to 0:
  output[count[a[i]]-1]=a[i]
  '''

def csort(arr):

  if not arr:

    return []
  max_val=max(arr)
  count=[0]*(max_val+1)

  # freq
  for num in arr:
    count[num]+=1
  # count
  for i in reversed(arr):
    count[i]+=count[i-1]
  output=[0]*len(arr)

  # stable sort

  for num in arr:
    output[count[num]-1]=num
    count[num]-=1

  # coping sorted list
  for i in range(len(arr)):
    arr[i]=output[i]
arr=[4,2,2,8,3,3,1]
print("Before:",arr)
csort(arr)
print("After:",arr)

